(* Copyright 2013 Martin Korp, Christian Sternagel, Harald Zankl
 * GNU Lesser General Public License
 *
 * This file is part of TTT2.
 * 
 * TTT2 is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 * 
 * TTT2 is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 * License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with TTT2. If not, see <http://www.gnu.org/licenses/>.
 *)

(*** OPENS ********************************************************************)
open Util;;
open Rewritingx;;
open Logic.Operators;;

(*** MODULES (part 1) *********************************************************)
module Co = Complexity;;
module F = Format;;
module Fun = Function;;
module Var = Variable;;
module Number = Logic.Number;;
module Monad = Rewritingx.Monad;;
module Pos = Position;;
module Sig = Signature;;
module E = FixedBaseElementary;;

(*** TYPES ********************************************************************)

type t = {
 degree : int;
 direct : bool; 
 interpretation : (string * E.t) list;
 context : E.context;
 input : Problem.t;
 output :Problem.t;
};;

type flags = {
 db : int ref;
 dir : bool ref;
 help : bool ref;
 eval : bool ref;
 id : int ref;
 inter : string ref;
 min : int ref;
 ob : int ref;
 od : int ref;
 p : bool ref;
 p2 : bool ref;
 pr : bool ref;
 pr2 : bool ref;
 time : bool ref; 
 test : bool ref;
};;


(*** GLOBALS ******************************************************************)
let code = "fbi";;
let name = "Fixed Base elementary Interpretation Processor";;
let comment = "Applies fixed based elementary interpretations."
let keywords = ["elementary interpretation";"termination"];;

let flags = {
 db = ref max_int;
 dir = ref false;
 help = ref false;
 eval = ref false;
 id = ref 1;
 inter = ref "";
 min = ref 1;
 ob = ref max_int;
 od = ref 1;
 p = ref false;
 p2 = ref false;
 time = ref false; 
 pr = ref false; (*debugging*)
 pr2 = ref false; (*debugging*)
 test = ref false; (*debugging*)
};;

(*
type context = {
 arith              : Logic.arith;
 interpretations    : (Fun.t, E.t) Hashtbl.t;
 ht_con             : (Var.t * E.t, Logic.p * Logic.p) Hashtbl.t;
 ht_geq             : (E.t * E.t, Logic.p * Logic.p) Hashtbl.t;
 ht_gt              : (E.t * E.t, Logic.p * Logic.p) Hashtbl.t;
 ht_eq              : (E.t * E.t, Logic.p * Logic.p) Hashtbl.t;
 ht_avars           : (Logic.a, Logic.a) Hashtbl.t;
 ht_pvars           : (Logic.p, Logic.p) Hashtbl.t;
 ht_zero            : (t, Logic.p * Logic.p) Hashtbl.t;
 gt_encodings       : (Rule.t,Logic.p) Hashtbl.t;
 geq_encodings      : (Rule.t,Logic.p) Hashtbl.t;
 out_deg            : int;
 p_constraints      : Logic.p;
 p_compatible       : Logic.p;
 state              : Sig.t;
 subterm_encodings  : (Term.t,E.t * E.t) Hashtbl.t;
};;
*)

let spec =
 let spec = [
  ("-direct",Arg.Set flags.dir,"Try to finish termination proof.");
  ("--help",Arg.Set flags.help,"Prints information about flags.");
  ("-help",Arg.Set flags.help,"Prints information about flags.");
  ("-h",Arg.Set flags.help,"Prints information about flags.");
  ("-cache",Arg.Clear E.cache, "Switch off caching (default: on).");
  ("-ib",Arg.Int ((:=) flags.min <.> Int.bit_max),
   "Defines the number of bits used to represent matrix entries (same as \
   `-min' but in bits).");
  ("-id",Arg.Set_int flags.id,"Input degree of ordinal (default 1).");
  ("-inter",Arg.Set_string flags.inter,"Set interpretation (goodstein, \
    hydra, worms, none).");
  ("-max",Arg.Int ((:=) flags.ob <.> Int.bits),
   "Defines the maximum number that can appear as intermediate result.");
  ("-min",Arg.Set_int flags.min,
   "Defines the minimum matrix entry that should be representable.");
  ("-ob",Arg.Set_int flags.ob,
   "Defines the number of bits used to represent intermediate results \
    (same as `-max' but in bits)");
  ("-od",Arg.Set_int flags.od,"Output degree of ordinal (default 1).");
  ("-p",Arg.Set flags.p,
   "Print encoding in SMT-LIB format v1.2 and fail");
  ("-p2",Arg.Set flags.p2,
   "Print encoding in SMT-LIB format v2.0 and fail");
  ("-pc",Arg.Set E.t_pc,
   "Print comparisons interpretation (debugging)");
  ("-pi",Arg.Set E.t_pi,
   "Print abstract interpretation (debugging)");
  ("-pm",Arg.Set E.t_pm,
   "Print multiplication (debugging)");
  ("-pp",Arg.Set E.t_pp,
   "Print comPosition (debugging)");
  ("-pr",Arg.Set flags.pr,
   "Print rules (evaluated wrt abstract interpretation) (debugging)");
  ("-pr2",Arg.Set flags.pr2,
   "Print rules (evaluated wrt concrete interpretation) (debugging)");
  ("-itp",Arg.Set_string E.t_itp,"use concrete interpretation (for debugging).");
  ("-fresh",Arg.Set E.t_fresh,"use fresh variables for concrete interpretation (for debugging).");
  ("-t",Arg.Set flags.time,
   "Print timing information (default:off)");
  ("-eval",Arg.Set flags.eval,"Evaluate expressions (for debugging).");
  ("-test",Arg.Set flags.test,"(for debugging).");
  ] in
 Arg.alignx 80 spec
;;

let help = (comment,keywords,List.map Triple.drop_snd spec);;

let rule_inter = ref []

(*** MODULES (part 2) *********************************************************)
module Statex = struct type t = E.context end;;
module Made = Util.Monad.Transformer.State (Statex) (Logic.Monad);;
open Made;;

(*** FUNCTIONS ****************************************************************)
let init _ =
 flags.db := max_int;
 flags.dir := false;
 flags.help := false;
 flags.id := 1;
 flags.min := 1;
 flags.ob := max_int;
 flags.od := 1;
;;

(* Constructors and Destructors *)
let make deg dir i context input output = {
 degree = deg;
 direct = dir;
 interpretation = i;
 context = context;
 input = input;
 output = output;
};;

let get_ip p = p.input;;
let get_op p = p.output;;

(* Complexity Bounds *)
let complexity c p = Co.other;;

(* Compare Functions *)
let equal p q =
 Problem.equal p.input q.input && Problem.equal p.output q.output
;;

(* Printers *)
let fprintf_var c fmt x = F.fprintf fmt "%s" (Sig.find_var_name x c);;


(*
(* for concrete interpretations *)
let fprintf_intp_p s fmt (f,o) = 
 let rec print fmt = function
  | o when O.is_izero o -> F.fprintf fmt "0"
  | (O.O _) as o -> (
   let mono fmt i f c = 
    if Number.is_zero c then ()
    else if Number.is_one c then F.fprintf fmt "%a" (fprintf_var s) i
    else F.fprintf fmt "%a*%a" (fprintf_var s) i f c
   in
   let mono' fmt (x,c) = mono fmt x Number.fprintf c in
   let pos = List.filter (fun (x,c) -> not (Number.is_zero c)) in
   let poly sep fmt l = List.fprintf mono' sep fmt (pos l) in
   if (List.exists (fun (x,c) -> not (Number.is_zero c)) (O.inter_c o)) then
    (F.fprintf fmt "%a" (poly " + ") ((*List.rev*) (O.inter_c o));
     if not (Number.is_zero (O.inter_cexp o)) then F.fprintf fmt " + ");
   if not (Number.is_zero (O.inter_cexp o)) then (
    F.fprintf fmt "omega^(";
    print fmt (O.inter_exp o);
    F.fprintf fmt ")";
    let ce = O.inter_cexp o in
    if not (Number.is_one ce) then F.fprintf fmt "*%a" Number.fprintf ce);
   let ncs = O.inter_nc o in
   if (List.exists (fun (x,c) -> not (Number.is_zero c)) ncs) then
    F.fprintf fmt " (+) %a" (poly " (+) ") ncs;
   if not (Number.is_zero  (O.inter_c0 o)) then
    F.fprintf fmt " (+) %a" Number.fprintf (O.inter_c0 o))
 in
 let xs = O.ivars o in
 F.fprintf fmt "@[%s(%a) = %a@]" f 
  (List.fprintf (fun fmt x -> F.fprintf fmt "%a" (fprintf_var s) x) ",") xs
  print o
;;

(* for abstract interpretations *)
let fprintf_inter s vars fmt (f,o) = 
 let rec print fmt = function
  | O.Zero -> F.fprintf fmt "0"
  | (O.Ord _) as o ->
   let fc i fmt (x,c) = F.fprintf fmt "%a %a" (fprintf_var s) x Logic.fprintf_a c in
   let fl sep fmt = List.fprintfi fc sep fmt in
   F.fprintf fmt "%a + omega^(%!" (fl " + ") (O.cs o);
   print fmt (O.exp o);
   F.fprintf fmt ") %a (+) %a" Logic.fprintf_a (O.cexp o) (fl " (+) ") (O.ncs o);
   F.fprintf fmt " + %a%!" Logic.fprintf_a (O.c0 o)
 in
 let print_vars vars fmt xs = 
  if vars then F.fprintf fmt "(%a)" 
   (List.fprintf (fun fmt x -> F.fprintf fmt "%a" (fprintf_var s) x) ",") xs
  else F.fprintf fmt "" in
 let xs = List.map fst (O.cs o) in
 F.fprintf fmt "%s%a = %a" f (print_vars vars) xs print o;
;;

let print_inter s ?(vars=true)f i =
 Format.fprintf Format.std_formatter "@[%a@]@\n"
  (fun ppt -> fprintf_inter s vars ppt) (f,i)

let fprintfx fs p = failwith "XML not supported" ;;
*)

(* Processor *)
(* administrative functions *)
let (>>=) = Made.(>>=);;

(*
let print state f = 
 let _ = Sig.fprintf_fun Format.std_formatter f state in
 let _ = Format.printf " -> ari:%d@\n" (Sig.find_ari f state) in
 ()
;;
*)

let context state problem =
 let arith = {
  Logic.min = Int64.of_int !(flags.min);
  neg       = false;
  rat       = 1;
  real      = false;
  minf      = false}
 in
 {E.arith              = arith;
  ht_avars           = Hashtbl.create 512;
  ht_con             = Hashtbl.create 512;
  ht_eq              = Hashtbl.create 512;
  ht_geq             = Hashtbl.create 512;
  ht_gt              = Hashtbl.create 512;
  ht_pvars           = Hashtbl.create 512;
  ht_zero            = Hashtbl.create 512;
  interpretations    = Hashtbl.create 512;
  gt_encodings       = Hashtbl.create 512;
  geq_encodings      = Hashtbl.create 512;
  out_deg            = !(flags.od);
  p_constraints      = Logic.top;
  p_compatible       = Logic.top;
  state              = state;
  subterm_encodings  = Hashtbl.create 512;
 }
;;

let cache_m tbl f k = 
 if Hashtbl.mem tbl k then return (Hashtbl.find tbl k)
 else (f k >>= fun v -> (Hashtbl.add tbl k v; return v))
;;

(* functions lifted from Logic into Made *)
let fresh_arith = get >>= fun s -> lift (Logic.fresh_arith s.E.arith);;
let fresh_arith_spec arith = lift (Logic.fresh_arith arith);;
let fresh_bool = get >>= fun s -> lift Logic.fresh_bool;;
let ($&$) = liftM2 (<&>);;
let ($|$) = liftM2 (<|>);;
let ($->$) = liftM2 (<->>);;
let ($<$) = liftM2 (<<>);;
let ($>$) = liftM2 (<>>);;
let ($>=$) = liftM2 (<>=>);;
let ($<=$) = liftM2 (<<=>);;
let ($+$) = liftM2 (<+>);;
let eval_a a ass = a >>= fun a -> lift (Logic.eval_a a ass)
(* >>= fun va -> Format.printf "%a: %a@\n%!" Logic.fprintf_a a Number.fprintf va; return va *)
;;
let eval_p p ass = p >>= fun p -> lift (Logic.eval_p p ass);;
let map_op op f ls = sequence (List.map f ls) >>= (return <.> op);;
let mapi_op op f ls = sequence (List.mapi f ls) >>= (return <.> op);;
let gen_op op f n = sequence (List.gen f n) >>= (return <.> op);;
let map_and f = map_op Logic.big_and f;;
let mapi_and f = mapi_op Logic.big_and f;;
let gen_and f = gen_op Logic.big_and f;;
let map_or f = map_op Logic.big_or f;;
let mapi_or f = mapi_op Logic.big_or f;;
let gen_or f = gen_op Logic.big_or f;;
let solve phi = phi >>= fun phi -> lift (Logic.solve phi);;

(* state monad interaction *)
let is_dp f = get >>= fun c -> return (Sig.is_dp f c.E.state);;
let arity f = get >>= fun c -> return (Sig.find_ari f c.E.state);;
let fun_name f = get >>= fun c -> return (Sig.find_fun_name f c.E.state);;
let var_name f = get >>= fun c -> return (Sig.find_var_name f c.E.state);;
let id f = get >>= fun c -> return (fst (Sig.to_string_fun f c.E.state));;

(* encoding starts here *)
let degree () = return !(flags.id)

(*not side-effect free*)
let eval txt p = 
 if not !(flags.eval) then (return p)
 else
  (return p) $&$ E.side_conditions () >>= fun phi ->
  (* solve (return phi) >>= fun a -> *)
  let a = Logic.run ~obits:!(flags.ob) (Logic.solve phi) in
  let b = match a with 
   | None -> false
   | Some _ -> true
  in Format.printf "%s: %b@\n@?" txt b;
  return p
;;

let rec encode_term t = get >>= fun c ->
 cache_m c.E.subterm_encodings etc t
and etc = function
 | Term.Var x -> 
  var_name x >>= fun x ->
  let o = E.make_var x in return (o,o)
 (* | (Term.Fun (f,[])) -> interpretation f >>= fun o -> return (o,o) *)
 | (Term.Fun (f,ts)) ->
  E.interpretation !(flags.id) f >>= fun o ->
  if List.for_all Term.is_var ts && (List.unique ts = ts) then
   let to_var = function Term.Var x -> var_name x | _ -> failwith "no var" in
   map to_var ts >>= fun xs ->
   let o' = E.substitute_vars xs o in
   return (o',o')
  else
   (* fun_name f >>= fun s -> *)
   (* get >>= fun c -> *)
   (* if !E.t_pi then Format.printf "%a" E.fprintf_intp_p (*c.state*) (s,o); *)
   map encode_term ts >>= fun os ->
   E.interpret_with_args os o 
;;

let fprintf_orient_rule c fmt rule =
 let (s,l) = Term.to_strings c.E.state (Rule.lhs rule) in
 let (s,r) = Term.to_strings c.E.state (Rule.rhs rule) in
 F.fprintf fmt "@\n[%s -> %s]" l r;
 let ll = snd (Hashtbl.find c.E.subterm_encodings (Rule.lhs rule)) in
 let uu = fst (Hashtbl.find c.E.subterm_encodings (Rule.lhs rule)) in
 F.fprintf fmt "@\n@[%a >= %a@]" E.fprintf ll E.fprintf uu;
;;

let greater_equal_rule rule = 
 get >>= fun c -> 
 encode_term (Rule.lhs rule) >>= fun (_,ll) ->
 encode_term (Rule.rhs rule) >>= fun (ur,_) ->
 if !(flags.pr) then fprintf_orient_rule c F.std_formatter rule;
 rule_inter := (ll,ur) :: !rule_inter;
 E.geq ll ur >>= eval "geq" 
;;

let greater_equal_rule rule = get >>= fun c ->
 if Rule.is_embedded rule then
  return Logic.top 
 else
  cache_m c.E.geq_encodings (greater_equal_rule) rule
;;

let greater_rule rule = 
(*
 if Rule.is_embedded rule then return Logic.top 
 else if Term.is_var (Rule.rhs rule) then
  encode_term (Rule.lhs rule) >>= fun (_,ll) ->
  let x = match (Rule.rhs rule) with | Term.Var x -> x in
  O.con x ll $&$ return (((O.c0 ll <>> Logic.zero) <|> (O.cexp ll <>> Logic.zero)))
 else 
*)
  encode_term (Rule.lhs rule) >>= fun (_,ll) ->
  encode_term (Rule.rhs rule) >>= fun (ur,_) ->
  get >>= fun c ->
(*
 (if !(flags.pr) then (
  get >>= fun c -> let s = c.E.state in
  let (s,l) = Term.to_strings s (Rule.lhs rule) in
  F.printf "%a@\n" E.fprintf_intp_p (l,ll);
  let (s,r) = Term.to_strings s (Rule.rhs rule) in
  F.printf "%a@\n" E.fprintf_intp_p (r,ur);
  return ())
 else return ()) >>= fun _ ->
*)
  E.gt ll ur >>= eval "gt" 
;;

let greater_rule rule = get >>= fun c ->
 cache_m c.E.gt_encodings greater_rule rule
;;

let encode_geq s w = map_and greater_equal_rule (s@w);;

let encode_gt s w = get >>= fun c -> 
 let s = if !(flags.dir) then s else List.rev_append s w in
 let op = (if !(flags.dir) then Logic.big_and else Logic.big_or) in
 map_op op greater_rule s
;;

let encode strict weak = get >>= fun c ->
 let (s, w) = Pair.map Trs.to_list (strict, weak) in
 let fs = Trs.funs (Trs.union strict weak) in
 encode_geq s w $&$
 encode_gt s w $&$
 map_and (E.well_defined_f !(flags.id)) fs $&$
 map_and (E.monotone_f !(flags.id)) fs $&$
 (E.side_conditions ()) $&$
 return Logic.top
;;

let encode p =
 let (s,w) = Problem.get_sw p in
 encode s w
;;

let get_interpretation ass f = fun_name f >>= fun name ->
 E.interpretation !(flags.id) f >>= fun i ->
 E.eval_interpretation ass i >>= fun evi ->
 (*overwrite parametric interpretation for pretty printing*)
  get >>= fun c -> 
   Hashtbl.clear c.E.subterm_encodings;
   Hashtbl.replace c.E.interpretations f evi;
 return (name,evi)
;;

let decode_interpretation ass p =
 let (s,w) = Problem.get_sw p in
 let trs = Trs.union s w in
 (*print_interpreted_rules ass >> *)
 Made.sequence (List.map (get_interpretation ass) (Trs.funs trs))
;;

let decode_rule ass rule = liftM not (eval_p (greater_rule rule) ass);;

let decode_trs ass trs = 
 Made.filter (decode_rule ass) (Trs.to_list trs) >>= (return <.> Trs.of_list)
;;

let decode_weak ass w = decode_trs ass w;;

let decode ass p = get >>= fun c -> 
 let (s,w) = Problem.get_sw p in
 decode_trs ass s >>= fun s' ->
 decode_weak ass w >>= fun w' ->
 return (Problem.set_sw s' w' p)
;;

(*printing *)

let fprintf_orient c fmt p =
 let (s,w) = Problem.get_sw p in
 let rs = Trs.to_list (Trs.union s w) in
 F.fprintf fmt "@[<1>orient:";
 List.iter (fprintf_orient_rule c fmt) rs;
 F.fprintf fmt "@]@\n";
;;

let solve s fs p =
 let configurate s = F.printf "%s@\n%!" s; flags.help := true in
 (try init (); Arg.parsex code spec fs with Arg.Bad s -> configurate s);
 if !(flags.help) then (Arg.usage spec ("Options for "^code^":"); exit 0);
 let c = context s p in
 Logic.run ~dbits:!(flags.db) ~obits:!(flags.ob) (
  Made.run c (encode p >>= fun phi ->
   (* if !(flags.p) || !(flags.p2) then print_formula fs phi else *)
   let t = Unix.gettimeofday () in
   Made.lift (Logic.solve phi) >>= function
    | None -> return None
    | Some ass -> 
    if !(flags.time) then (
     let t = Unix.gettimeofday () -. t in
     Format.printf "time in solver: %f\n%!" t;
     E.print_timing ();
    );
     decode ass p >>= fun p' -> 
     decode_interpretation ass p >>= fun i ->
     (*hack: to get new interpretation*)
     encode p >>= fun _ ->
     get >>= fun c -> 
     return (Some (c.E.state,make !(flags.id) !(flags.dir) i c p p'))))
;;

(* wrap into state monad *)
let (>>=) = Monad.(>>=);;
let (>>) = Monad.(>>);;
let solve fs p =
 if (Problem.is_sp p) || (Problem.is_rp p) || (Problem.is_dp p)  then
  Monad.get >>= fun s -> match solve s fs p with
    | None -> Monad.return None
    | Some (s,p) -> Monad.set s >> Monad.return (Some p)
 else
  Monad.return None
;;

let (>>=) = Monad.(>>=);;
let (>>) = Monad.(>>);;


let fprintf fs fmt p  = 
 F.fprintf fmt "@[<1>%s:@\ndegree: %i" name p.degree;
 F.fprintf fmt "@\n@[<1>interpretation:@\n";
 E.fprintf_intp fmt p.interpretation >>= fun _ ->
 F.fprintf fmt "@\n@[<1>orientation:@\n";
 fprintf_orient p.context fmt p.input;
 F.fprintf fmt "@]@\n@[<1>problem:@\n";
 Problem.fprintfm fmt p.output >>= fun _ ->
 F.fprintf fmt "@]@\n"; List.hd fs fmt >>= fun _ ->
 Monad.return (F.fprintf fmt "@]")
;;

let fprintfx fs fmt p  = failwith "Fbi: fprintfx not implemented";;

